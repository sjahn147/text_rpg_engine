# 게임 엔진 QA 테스트 계획

## 목적

게임 엔진의 핵심 기능과 데이터 무결성을 체계적으로 검증하기 위한 종합 QA 테스트 계획입니다.

## 테스트 범위

### 1. 게임 시작 플로우 (Game Start Flow)

#### 1.1 기본 게임 시작
- **시나리오**: 플레이어 템플릿과 시작 셀을 지정하여 게임 시작
- **검증 항목**:
  - 세션 생성 (`runtime_data.active_sessions`)
  - 셀 인스턴스 생성 (`runtime_data.runtime_cells` → `reference_layer.cell_references`)
  - 플레이어 인스턴스 생성 (`runtime_data.runtime_entities` → `reference_layer.entity_references` → `runtime_data.entity_states`)
  - 외래키 제약조건 준수 (생성 순서 검증)
  - 트랜잭션 원자성 (모든 작업이 성공하거나 모두 롤백)
  - API 응답 형식 및 상태 코드

#### 1.2 기본 시작 셀 자동 선택
- **시나리오**: 시작 셀을 지정하지 않고 게임 시작
- **검증 항목**:
  - 기본 셀 자동 선택 로직
  - 셀이 없을 경우 적절한 에러 처리

#### 1.3 게임 시작 실패 케이스
- **시나리오**: 잘못된 플레이어 템플릿 ID 또는 셀 ID
- **검증 항목**:
  - 적절한 에러 메시지 반환
  - 부분적 데이터 생성 방지 (트랜잭션 롤백)
  - 데이터베이스 무결성 유지

### 2. 데이터 무결성 검증 (Data Integrity)

#### 2.1 외래키 제약조건 검증
- **검증 항목**:
  - `cell_references.runtime_cell_id` → `runtime_cells.runtime_cell_id`
  - `entity_references.runtime_entity_id` → `runtime_entities.runtime_entity_id`
  - `entity_states.runtime_entity_id` → `runtime_entities.runtime_entity_id`
  - `cell_occupants.runtime_cell_id` → `runtime_cells.runtime_cell_id`
  - `cell_occupants.runtime_entity_id` → `runtime_entities.runtime_entity_id`

#### 2.2 SSOT (Single Source of Truth) 검증
- **검증 항목**:
  - `entity_states.current_position`이 SSOT
  - `cell_occupants`는 자동 동기화 (트리거 검증)
  - `cell_occupants` 직접 쓰기 방지 (트리거 검증)

#### 2.3 데이터 생성 순서 검증
- **검증 항목**:
  - 셀 인스턴스: `runtime_cells` → `cell_references`
  - 엔티티 인스턴스: `runtime_entities` → `entity_references` → `entity_states`
  - 순서 위반 시 외래키 제약조건 위반 발생 확인

### 3. 게임 상태 관리 (Game State Management)

#### 3.1 게임 상태 조회
- **시나리오**: 세션 ID로 게임 상태 조회
- **검증 항목**:
  - 세션 존재 여부 확인
  - 플레이어 정보 조회
  - 현재 셀 정보 조회
  - JSONB 필드 파싱 정확성

#### 3.2 플레이어 인벤토리 조회
- **시나리오**: 플레이어 인벤토리 및 장착 아이템 조회
- **검증 항목**:
  - 인벤토리 JSONB 파싱
  - 장착 아이템 정보 조회
  - 아이템 템플릿 정보 조회

#### 3.3 플레이어 캐릭터 정보 조회
- **시나리오**: 플레이어 스탯, HP/MP, 장비 정보 조회
- **검증 항목**:
  - 스탯 계산 정확성
  - HP/MP 계산 정확성
  - 장착 아이템 정보 정확성

### 4. 셀 이동 (Cell Movement)

#### 4.1 플레이어 이동
- **시나리오**: 플레이어를 다른 셀로 이동
- **검증 항목**:
  - `entity_states.current_position` 업데이트
  - `cell_occupants` 자동 동기화
  - 이전 셀에서 제거 확인
  - 새 셀에 추가 확인
  - 트랜잭션 원자성

#### 4.2 현재 셀 정보 조회
- **시나리오**: 현재 셀의 엔티티, 오브젝트 정보 조회
- **검증 항목**:
  - 셀 정보 정확성
  - 엔티티 목록 정확성
  - 오브젝트 목록 정확성
  - 연결된 셀 정보 정확성

### 5. 상호작용 (Interactions)

#### 5.1 엔티티 상호작용
- **시나리오**: NPC와 상호작용 (examine, dialogue 등)
- **검증 항목**:
  - 엔티티 존재 확인
  - 상호작용 타입별 처리
  - 응답 메시지 정확성

#### 5.2 오브젝트 상호작용
- **시나리오**: 오브젝트와 상호작용 (examine, pickup 등)
- **검증 항목**:
  - 오브젝트 존재 확인
  - 상호작용 타입별 처리
  - 오브젝트 상태 변경

#### 5.3 아이템 조작
- **시나리오**: 아이템 사용, 장착, 해제, 버리기
- **검증 항목**:
  - 인벤토리 업데이트
  - 장착 슬롯 관리
  - 아이템 효과 적용

### 6. API 엔드포인트 검증 (API Endpoints)

#### 6.1 게임 시작 API
- **엔드포인트**: `POST /api/gameplay/start`
- **검증 항목**:
  - 요청/응답 스키마 검증
  - 상태 코드 (201 Created)
  - 에러 처리 (400, 500)

#### 6.2 게임 상태 조회 API
- **엔드포인트**: `GET /api/gameplay/state/{session_id}`
- **검증 항목**:
  - 상태 코드 (200 OK)
  - 응답 스키마 검증
  - 세션 없음 처리 (404)

#### 6.3 플레이어 이동 API
- **엔드포인트**: `POST /api/gameplay/move`
- **검증 항목**:
  - 상태 코드 (200 OK)
  - 이동 성공/실패 처리
  - 잘못된 셀 ID 처리 (400)

### 7. 에러 처리 및 엣지 케이스 (Error Handling & Edge Cases)

#### 7.1 존재하지 않는 리소스
- **검증 항목**:
  - 존재하지 않는 세션 ID
  - 존재하지 않는 셀 ID
  - 존재하지 않는 엔티티 ID
  - 적절한 에러 메시지 및 상태 코드

#### 7.2 잘못된 데이터 형식
- **검증 항목**:
  - 잘못된 JSON 형식
  - 필수 필드 누락
  - 잘못된 데이터 타입
  - 적절한 검증 에러 메시지

#### 7.3 동시성 테스트
- **검증 항목**:
  - 동일 세션에 대한 동시 요청 처리
  - 트랜잭션 격리 수준
  - 데드락 방지

#### 7.4 대용량 데이터 테스트
- **검증 항목**:
  - 많은 엔티티가 있는 셀 조회 성능
  - 많은 아이템이 있는 인벤토리 조회 성능

### 8. 트랜잭션 검증 (Transaction Verification)

#### 8.1 원자성 검증
- **검증 항목**:
  - 게임 시작 중 일부 작업 실패 시 전체 롤백
  - 셀 이동 중 실패 시 상태 복구
  - 상호작용 중 실패 시 상태 복구

#### 8.2 일관성 검증
- **검증 항목**:
  - 트랜잭션 전후 데이터 일관성
  - 외래키 제약조건 일관성
  - SSOT 일관성

### 9. 성능 테스트 (Performance Testing)

#### 9.1 응답 시간
- **검증 항목**:
  - 게임 시작 응답 시간 < 1초
  - 셀 조회 응답 시간 < 500ms
  - 상호작용 응답 시간 < 500ms

#### 9.2 동시 사용자
- **검증 항목**:
  - 동시 게임 시작 (10개 세션)
  - 동시 셀 조회 (50개 요청)
  - 동시 상호작용 (100개 요청)

## 테스트 우선순위

### P0 (Critical - 즉시 수정 필요)
1. 게임 시작 플로우 전체 검증
2. 외래키 제약조건 검증
3. 데이터 생성 순서 검증
4. SSOT 검증

### P1 (High - 빠른 시일 내 수정)
1. API 엔드포인트 검증
2. 트랜잭션 원자성 검증
3. 에러 처리 검증

### P2 (Medium - 계획된 수정)
1. 성능 테스트
2. 동시성 테스트
3. 대용량 데이터 테스트

## 테스트 실행 전략

### 1. 단위 테스트 (Unit Tests)
- 개별 메서드/함수 검증
- Mock 사용 가능
- 빠른 실행

### 2. 통합 테스트 (Integration Tests)
- 실제 데이터베이스 사용
- 전체 플로우 검증
- 외래키 제약조건 검증

### 3. E2E 테스트 (End-to-End Tests)
- API 엔드포인트부터 데이터베이스까지 전체 검증
- 실제 사용 시나리오 시뮬레이션

## 테스트 데이터 관리

### 1. 테스트 데이터 생성
- 각 테스트 전 필요한 데이터 자동 생성
- 테스트 후 자동 정리

### 2. 테스트 격리
- 각 테스트는 독립적으로 실행 가능
- 테스트 간 데이터 간섭 방지

### 3. 테스트 데이터 재사용
- 공통 테스트 데이터는 fixture로 관리
- 테스트 간 공유 가능

## 테스트 실행 및 리포팅

### 1. 테스트 실행
```bash
# 전체 테스트 실행
pytest tests/qa/ -v

# 특정 카테고리만 실행
pytest tests/qa/test_game_start.py -v

# 커버리지 포함
pytest tests/qa/ --cov=app --cov-report=html
```

### 2. 테스트 리포팅
- 테스트 결과 요약
- 실패한 테스트 상세 정보
- 커버리지 리포트

## 지속적 개선

### 1. 테스트 커버리지 모니터링
- 코드 커버리지 80% 이상 유지
- 누락된 경로 식별 및 테스트 추가

### 2. 테스트 유지보수
- 코드 변경 시 관련 테스트 업데이트
- 중복 테스트 제거
- 테스트 성능 최적화

